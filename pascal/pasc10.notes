THE FOLLOWING ARE SOME USER NOTES ON PASCAL FOR THE
DEC20. THEY ARE COMPILED FROM PAINFUL EXPERIENCE AND
ARE BELIEVED TO BE ACCURATE. LET'S HOPE THAT WE CAN
AVOID REINVENTING THE WHEEL...
 

1)	REAL NUMBERS.
   
REAL NUMBERS ON THE DEC20 MUST BE TYPED IN WITH A
DIGIT FOLLOWING THE DECIMAL POINT. THUS:

	3.0	IS ACCEPTABLE WHILE:
	3.	IS NOT.
THIS IS STANDARD PASCAL, BUT THOSE WHO MAY BE
USED TO OTHER INPUT SYSTEMS (SUCH AS THAT USED 
BY FORTRAN) MAY TEND TO FORGET THIS.

 
2)	STACK OVERRUNNING HEAP

FROM TIME TO TIME, WHEN WORKING WITH VERY SMALL
PROGRAMS (LIKE WHILE TRYING OUT COMBINATIONS OF
THINGS FOR THIS DOCUMENTATION) I HAVE ENCOUNTERED
THE FOLLOWING MESSAGE:

[LNKXCT PNAME EXECUTION]

%?     STACK OVERRUNS HEAP: RETRY W/MORE CORE
EXIT

I MUST ADMIT THAT I DON'T REALLY KNOW WHAT THAT IS
SUPPOSED TO MEAN (EXCEPT PERHAPS IN A FUZZY 511'ISH
WAY), BUT I HAVE FOUND A KLUDGE AROUND IT.

IF YOU CAUSE YOUR PROGRAM TO GET LARGER (IE., USE MORE
CORE) THE MESSAGE GOES AWAY. THE EASIEST WAY THAT I
CAN THINK OF TO EXPAND THE SIZE OF YOUR PROGRAM
WITHOUT CHANGING ITS FUNCTION IS TOO MERELY DECLARE
A DUMMY VARIABLE IN YOUR VAR SECTION. TOWARD THAT END,
I HAVE INSERTED THE FOLLOWING STMT IN SEVERAL PROGS
WITH COMPLETE SUCCESS:

VAR	A,B,C : INTEGER;
	.
	.
	.
	M : ARRAY[1..1000] OF INTEGER; (* INSERT THIS LINE *)
	.
	.
	.
BEGIN
	.
	.
	.
END.

I'M REASONABLY SURE THAT A SMALLER ARRAY WOULD WORK,
BUT AT THE TIME I DIDN'T REALLY FEEL LIKE WASTING ANY 
MORE TIME TO FIND OUT.
ONE OTHER POINT; THIS HAS ONLY HAPPENED IN SMALL 
PROGRAMS IN WHICH I WAS TRYING TO READ IN EITHER 
INTEGERS OR REALS FROM THE TERMINAL.
WEIRD...


3)	TERMINAL I/O CONSIDERATIONS

IN TRYING TO DO TERMINAL (IE., TTY) I/O IN
PASCAL, I RAN IN TO A FEW SNAGS. THE FACT THAT
IT CAN BE DONE AND IN A REASONABLE MANNER
DOESN'T SEEM SURPRISING, BUT THINGS DON'T
WORK QUITE LIKE THEY ARE DEPICTED IN EITHER
MANUAL (IE., WIRTH AND JENSEN'S BOOK, OR THE
PAPER MANUAL FROM GERMANY THAT R. FRANK HAS
AVAILABLE).
I WILL TRY TO EXPLAIN WHAT I HAVE FOUND OUT
AND I WELCOME ANY RETURN COMMENTS OR SUGGESTIONS.

A)	PROMPT CHARACTER

WHEN THE TTY IS FIRST OPENED FOR READING (THIS
IS DONE AUTOMATICALLY FOR YOU BY THE SYSTEM) IT 
PROMPTS YOU WITH AN ASTERISK ('*') AS FOLLOWS:

[LNKXCT PNAME EXECUTION]

*
AND HERE IT WAITS FOR YOUR FIRST INPUT.
I WOULD ASSUME THAT IN ANYTHING MORE IMPORTANT
THAN A TOY PROGRAM (IE., ONE WRITTEN SOLELY TO 
TEST SOME ASPECT OF PASCAL) THE WRITER WILL SUPPLY 
HIS OWN PROMPTS. THEREFORE, THE DESIRED COURSE OF 
ACTION AT THIS POINT IS TO JUST ENTER A 
CARRIAGE RETURN (CR). THIS SATISFIES PASCAL, AND YOUR
ROUTINE CAN CONTINUE.

B)	NUMERIC DATA

PART ONE - INPUT

	READ(TTY,VARLIST);
WHERE:
	TTY IS THE FILE NAME OF THE STANDARD FILE 'TTY'
	VARLIST IS A LIST OF VARIABLES TO BE INPUT,
	SEPARATED BY COMMAS. NOTE THAT NO VARIABLE IN
	THE VARLIST IS ALLOWED TO BE AN ELEMENT OF A
	RECORD OR A MEMBER OF AN ARRAY (IE., SUBSCRIPTED).

INPUT ITEMS MAY BE DELIMITED BY BLANKS OR BY <CR>'S. COMMAS
ARE NOT ACCEPTABLE DELIMITERS.

PART TWO - OUTPUT

	WRITE(TTY,V/FLIST); BREAK;
WHERE:
	TTY IS AS ABOVE
	V/FLIST IS A VARIABLE/FORMAT LIST AND IS OF THE
	FORM:

		VAR1:F1,VAR2:F2,...VARN:FN
	WHERE:
		VAR1...VARN ARE PROGRAM VARIABLES
		F1...FN ARE FORMAT SPECIFICATIONS
		THAT TAKES ON ONE OF THE FOLLOWING FORMS:

		E1	(PRINT E1 NUMBER OF CHARS; USED FOR
			INTEGERS)
		E1:E2  (FOR USE WITH REALS; E1=WIDTH OF THE
			TOTAL FIELD [>=8] AND E2 IS THE 
			NUMBER OF DIGITS TO THE RHS OF 
			THE DECIMAL POINT)
		E1:O   (THAT'S THE LETTER, NOT THE NUMBER -
			PRINT AN INTEGER, E1 LONG, IN OCTAL)
		E1:H   (PRINT AN INTEGER, E1 LONG, IN
			HEXADECIMAL)

B)	CHARACTER DATA

PART ONE - INPUT

	READ(TTY,DUMMY,VARLIST);
WHERE
	TTY IS AS ABOVE
	DUMMY IS A DUMMY VARIABLE (OF TYPE CHAR) THAT
	IS USED TO CLEAR OUT THE TTY'S INPUT BUFFER.
	THIS TOO, I FEAR, IS A BIT OF A KLUDGE,
	BUT WITHOUT IT, THE FIRST VARIABLE OF VARLIST GETS
	SET TO A BLANK - REGARDLESS OF WHAT WAS TYPED AS
	INPUT.
	ALL INPUT IS ON THE SAME LINE, NO DELIMITERS.
	A MORE INTELLIGENT (AND READABLE) APPROACH 
	WOULD BE TO GET ONE CHARACTER ITEM PER READ.
	NOTE, WHEN I INPUT VALUES FOR A SCALAR RANGE
	THAT CONSISTED OF WORDS LIKE 'PLUS' AND 'MINUS',
	THE ABOVE KLUDGE WAS NOT NEEDED. FOR AN EXAMPLE,
	EXAMINE THE PROGRAM <JENAL>CALC.PAS

PART TWO - OUTPUT

	WRITE(TTY,'THIS IS A STRING OUTPUT',V/FLIST); BREAK;
WHERE
	TTY IS AS ABOVE
	'THIS...' IS A SAMPLE STRING THAT WILL BE PRINTED
	AS IT WAS TYPED
	V/FLIST IS AS ABOVE, EXCEPT THAT ONLY FORM ONE
	IS DEFINED FOR CHAR DATA.

THE BREAK IS USED TO FORCE THE PRINTING OF THE TTY'S BUFFER
IMMEDIATELY. IF THE WRITE STMT IS AT THE END OF YOUR CODE,
THE BREAK CAN BE OMITTED. HOWEVER, IF THE WRITE IS IN
A LOOP OF ANY KIND, THE BREAK MUST BE THERE TO INSURE
PRINTING EACH TIME THROUGH THE LOOP.
NOTE:
WRITELN WILL NOT, REPEAT WILL NOT FORCE THE BUFFER TO 
BE PRINTED. WRITELN APPEARS TO HAVE ONLY ONE USEFUL
FUNCTION (IN THE CONTEXT OF TTY OUTPUT) AND THAT WILL BE 
DESCRIBED NEXT. SO FAR, I HAVE NOT DISCOVERED ANY USE 
FOR THE READLN STMT (AT LEAST NOT IN THE CONTEXT OF TTY INPUT).

C)	BLANK LINE INSERTION

IF YOU WANT TO INSERT A BLANK LINE BETWEEN TWO LINES OF
OUTPUT, OR BETWEEN A PROMPT MESSAGE AND THE SPACE FOR
ENTERING THE DATA, THE FOLLOWING WORKS QUITE NICELY:

	WRITE(TTY,'SOME PROMPTING MESSAGE'); BREAK;
	WRITELN(TTY); BREAK;  (* INSERT THIS LINE *)
	READ(TTY,DUMMY,A,B,...);

WRITELN, WITH JUST TTY AS ITS ARGUMENTS, WILL SET UP
A BLANK LINE TO BE PRINTED, AND THIS IS FORCED BY THE
PRESENCE OF THE BREAK FOLLOWING IT.
WRITELN MUST BE USED (WRITE WITH NO ARGUMENTS CAUSES AN
ERROR TO BE GENERATED AT COMPILE TIME) AND THE TWO 
BREAKS SHOWN ARE CRITICAL.


----------------------------------------------------------------

THAT IS ALL FOR NOW, MORE TO COME (POSSIBLY ON FILE I/O)
ASSUMING THIS TURNS OUT TO BE OF ANY USE TO ANYONE BUT ME.
PLEASE FORWARD ANY COMMENTS AND/OR SUGGESTIONS TO ME
IN MY DEC20 MAILBOX (JENAL).
THANKS TO R.FRANK, M.LEMON AND G.LINDSTROM.

			J.P.JENAL
			2/9/78

----------------------------------------------------------------
