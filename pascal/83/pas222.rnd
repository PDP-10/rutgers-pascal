.rm72.title PASCAL.DOC - Extended Addressing PASCAL
.c ;Extended Addressing PASCAL
.c ;January 1982
.b1.c ;Norm Samuelson
.c ;Sandia National Labs
.b1.c ;Charles Hedrick
.c ;Rutgers University
.nj.b2;This document describes changes made to the PASCAL compiler
(distributed by Charles Hedrick of Rutgers University) to add
support for Extended Addressing on the DEC-20.  The changes were
made by Norm Samuelson at Sandia National Labs, Albuquerque, NM,
during the Fall of 1981, and by Charles Hedrick during
the Spring of 1982.  Charles Hedrick is responsible for the current
form.  A number of changes have been made since Norm's work, so he
should not be held responsible for any bugs in the current system.
.tp15.hl1 Incompatible changes
.nj;A great deal of effort was put into making this version as compatible
as possible with previous versions at the source code level (ie: .REL files
generated by the old version will NOT work with those generated by the
new compiler or with the new library, they must be recompiled).
There are, however, at least a couple of changes which may be needed in
source programs even if extended addressing is NOT selected.
.hl2 Too many nested WITH statements
.nj;There is one change which will cause a few programs to not compile.
Due to a change in register allocation, one less register is available.
The error message associated with this is 'Too many nested WITH statements'.
If you run into this problem you will have to remove one with statement,
and use a qualified name instead.
.hl2 Order of loading
.nj;Because of the way extended addressing is implemented, when you
have more than one module,
you must load the main module first.  This is true even for
programs that do not use extended addressing.  If you don't load the
main program first, the loader will complain that .XSTRT is not
defined.  You can ignore this error if your program does not use
extended addressing.
.hl2 %CCLSW doesn't do anything on Tops-20
.nj;We now use Tops-20 entry vectors in the Tops-20 version.  This
means that the concept of run offset no longer applies.  The run offset
is only defined for Tops-10 programs.  For this reason, %CCLSW will
always be zero on Tops-20.  We are working on a way to set %CCLSW
on Tops-20.
.hl1 New Features
.nj;Most of the changes have to do with extended addressing, which is
an OPTION.
.hl2 Selecting the extended addressing option
.nj;Extended addressing mode is NOT the default.  It must be selected
with the /EXTEND switch or the (*$X+*) directive.  See the section below
on new directives for details.
.b1;Most programs which execute correctly in single section mode will execute
with no source changes in extended address mode, by simply recompiling
with /EXTEND specified.  Programs which run out of space in almost any way
in a single section will benefit from extended addressing.
See the section below on "Source Changes" for information on programs which
may cause problems when run in extended address mode.
.hl2 NEWL
.nj;A new procedure NEWL has been added to allocate memory in the
same section as the code.  This should be needed ONLY by programmers
who wish to make their own JSYS calls, since some old JSYSes require
local addresses.  If NEWL is called from a program running in section 0
(ie: a single section program), it is equivalent to a call to NEW, so
it will not cause problems in running the same program in both single-section
and extended-address modes.
.hl2 GETSECTIONS and RELSECTIONS
.nj;Two new procedures "GETSECTIONS" and "RELSECTIONS" have been added,
also for programmers who want to do their own JSYS calls.  In release 5
of TOPS-20 it will be possible to map whole sections of files into
memory, or to map whole sections of processes to other processes.
The calls to GETSECTIONS and RELSECTIONS look precisely like calls to
GETPAGES and RELPAGES with the following three exceptions:
.ls.le;The pointer returned by GETSECTIONS is a pointer to a whole
section rather than a single page.
.le;The number returned by GETSECTIONS and used by RLESECTIONS is
a section number, rather than a page number.
.le;The section number argument to GETSECTIONS is used by GETSECTIONS
as a "suggested" section number.  If the section by that number is
available it is allocated, otherwise the lowest numbered available
section is allocated.
.els
Note that like GETPAGES and RELPAGES, GETSECTIONS and RELSECTIONS
must be declared.  See EXTERN.PAS for their definitions.
.hl2 changes in compiler directives and switches
.nj;Each of these options can be selected by a directive in the source,
or by a switch to the compiler.  Some compiler switches required
minor changes to the EXEC to be allowed with COMPILE-class commands.
If your site does not have those exec changes installed you must run
the compiler directly, rather than thru a COMPILE-class command, to
give the switch.  If a directive is found in the source it overrides
the corresponding switch given to the compiler.
.hl3 /EXTEND or (*$X+*)
.nj;The extend switch or X+ directive tells the compiler to generate
code which will run in extended addressing mode.  The X directive
will NOT be recognized AFTER the PROGRAM statement.
.hl3 /STACK:n or (*$S:n*)
.nj;The stack switch or directive is used entirely differently in
the two modes.  In both cases it is an OCTAL number if given in
the /STACK:n form, and can be octal or decimal if using the (*$S:n*) form.
.b1;In single section mode it tells where the stack is
to start (an absolute address).  The default is the next page
boundary above the high segment.
.b1;In extended addressing mode,
it tells HOW MANY SECTIONS are to be used for the stack.
The stack MUST be the top N sections.  The default is 10 sections.
There are 31 sections available on the KL-10.  One section is
used for the code, some unknown number for the XDATA PSECT (see below),
one section for buffers, and the other 29 for the stack, heap, and
user-allocated sections. If the stack uses the default 10 sections, the
heap can use the other 19, less any allocated by the user. If the
assembly parameter SE%BUF in PASUNV is set to zero, buffers will
be allocated in the same section as the code.  This will limit the number
of files that can be open simultaneously, but will probably make it run
slightly faster, and will leave one more section for use by the stack or heap.
.hl2 Limits on data structure lengths
.nj;Packed arrays are currently limited to 128K words
when extended addressing is in effect.
.hl1 Extended address mode vs single section mode
.nj;All the differences in code generation are controlled by two variables
internally.  The first is EXTENDED__ADDRESSING which is the more visible
of the two.  It selects BLT or XBLT, and packed or unpacked stack management.
It is false by default, can be set via "/EXTEND", lastly it can be
set by (*$X+*).
.b1;The other internal variable is BITS__PER__ADDRESS,
which is either 18 or 36, based on EXTENDED__ADDRESSING.
It controls the size of pointers, which affects how they are handled
in packed records.
.hl1 The .XDATA PSECT
.nj;Single-section programs have two sections of contiguous data,
technically known as PSECT's.  These are refered to as the "low segment"
(the PSECT .LOW.) and the "high segment" (the PSECT .HIGH.).  The
low segment contains all data the is defined at the global level
(i.e. not within a procedure), and the high segment contains all of
the code.  In an extended core image, these two PSECT's still exist.
For various reasons, they are limited to fit into a single section of
256K.  Since it is not desirable to limit your global data to what
will fit in a single section, any global data structure that is
larger than 2 pages is put into a separate PSECT: the "extended data
area" (the PSECT .XDATA).  The reason for making this distinction
is that access to data in the same section (.LOW.) is slightly
faster than access to data in other sections.  Also, such "local"
accesses create less code, and use less space in the .REL file.
Thus we try to use .LOW. for simple variables and relatively small
objects.  .XDATA is a multi-section PSECT:  Objects that are put in
it can take up as much space as necessary.  Note that the compiler
makes no attempt to see that data in this PSECT will really fit
into your core image.  It is possible that it would take up so
much space that there would be no room at runtime for the stack,
heap, and I/O buffers.  If so, you will find this out when you
first start your program.  As with all other PSECT's, data from
multiple modules do not overlap:  The data from one module is
put into the PSECT starting at the end of the data from the
previous module.  [Note:  Currently LINK does not support
multi-section PSECT's.  For this reason, the effect described above
is simulated using Polish fixups and the .ASSIGN operator.  The user
should not notice the difference.]
.hl1 source changes for extended addressing
.nj;For most programs, no change in the source is required at all.
There are some things to look out for which may cause problems in
existing programs.  The following list is all the things I have
found that may cause such problems.
.ls.le;To hold an extended address, the size of a pointer
variable is 36 bits, so it is NOT possible to have anything else in
the same word as a pointer.  In particular, any PACKED RECORD which
includes a pointer should be looked at closely.
.le;Also, JSYS calls using the "a:b" construct to build halfwords
may cause trouble.  However, the most common use of "a:b" is probably
in making byte pointers (ie: "-1:b").  This is not necessary if "b" is
a packed array of characters, since simply specifying "b" will actually
put a byte pointer into the accumulator anyway.
.le;When it is necessary to have a local address (as required by some
old JSYSes, such as TBLUK) NEWL should be called, rather than NEW.
This will allocate memory in the same section as the code.  (In a
single section program, NEW and NEWL are equivalent).
.le;Since FORTRAN does not YET generate code which will run correctly
in a non-zero section, any program which calls FORTRAN subroutines MAY
not run correctly.  DIGITAL expects to support extended addressing in
version 7.  Until version 7 is released, a warning will be issued from
any program which calls FORINI (which is REQUIRED to enable I/O from
FORTRAN routines).
.els
.hl1 Internal Changes
.nj;In order to make PASCAL code run in a non-zero section, and to make
it work with FORTRAN v6 (Which is just now being released by DIGITAL),
a number of changes were made in the code generated by the compiler, and
in the runtime library.
.hl2 Register allocation
.nj;In order to make use of extended addresses easy, it was decided to
dedicate one register (14, called BIX or BIXREG) for use as in index
in most byte operations.  This is the reason for the possible
'Too many nested WITH statements' error which can cause an incompatibility
with previous versions of the compiler.
.hl2 Implementation of large procedures
.nj;The compiler has not been changed very much to deal with large objects.
The routine MACRO, though which all code generation goes, has simply been
modified so that if an address field would be larger than 18 bits, it
automatically generates an indirect reference.  (Actually things are
slightly more complex than that, because in some cases there is a limit of
17 bits).  Of course this does not work for instructions whose effective
address is something other than an actual address.  The most common example
of this is a MOVEI that is loading the size of an object.  Previously such
sizes were always no bigger than 18 bits.  Now they can be.  All such
instructions have been modified to use the new procedure MACRO3C instead
of MACRO3.  E.g. MACRO3(OP_MOVEI,REGC,SIZE) would become 
MACRO3C(OP_MOVE,REGC,SIZE).  MACRO3C will compile to an immediate if 
possible, but otherwise will generate a constant and use MOVE for it.
.hl2 Relocation into the .XDATA virtual PSECT
.nj;Because LINK does not support multi-section PSECT's yet, this
PSECT must be "faked".  There is a routine XPOLISH that can be used to
make the contents of any address be in effect relocated into this
PSECT.
.hl2 Changes for FORTRAN v6
.hl3 PASMEM and PASFOR
.nj;To work conveniently with v6 FOROTS, a call to RESET. in FOROTS
is required.  Once this is done, the memory manager in FOROTS can be
used to handle NEW and DISPOSE.  To make all this work, there are now
two different memory management routines in PASLIB.
.b1;If FORINI or FOREXI is called the module PASFOR is loaded,
which calls RESET. as part of startup, and turns all NEW and DISPOSE
calls into calls to FUNCT. in FOROTS.
Since extended addressing is not yet supported by FORTRAN, the following
is not very important, and it may change when FORTRAN does support it, but...
If you do use extended addressing with FORTRAN, NEW is handled by GETNEW
while NEWL and DISPOSE are handled by FOROTS, HEAP is NEVER used with FOROTS.
.b1;If neither FORINI nor FOREXI is ever called
then PASMEM is loaded instead.  PASMEM uses the normal PASCAL memory
management routines (either GETNEW, the simple memory manager, or
HEAP, the manager which provides both NEW and DISPOSE).
.b1;It is important to note that if PASFOR is used, or if the user calls
DISPOSE, then MARK and RELEASE will
NOT work (no error indication will be given when MARK or RELEASE,
but the RELEASE call may cause trouble later).
This is because MARK and RELEASE are compatible only with the simple
minded memory manager (GETNEW, but not HEAP or FOROTS).
.b1;Another word of caution.  If NEWL is used to allocate local storage
it should NOT be DISPOSEd of, since the DISPOSE routine may blow its mind.
.hl2 Other changes in PASLIB of interest to maintainers
.hl3 E.CRIT - critical section entry
.nj;To replace the somewhat clumsy checking for critical sections, a new
routine was added to the critical section management routines.  E.CRIT will
enter a critical section IF the user had not already done so.  If it
does, it puts a call to LEAVEC onto the stack, so that when the routine
which called E.CRIT is exited the critical section is exited too.  If
the user was already in a critical section, E.CRIT simply returns quickly,
leaving the user the responsibility to call LEAVEC himself.
.hl3 SN.COD
.nj;A new global variable named SN.COD contains the section number in
which the code is running.  It is used by those routines in PASLIB
which need to know whether single section or extended addressing is in
effect.  In particular it is often checked in memory management routines.
Most of the routines in PASLIB actually use the same identical code
whether they are in single section mode or extended address mode.
The only exceptions are DEBUG (which is PASCAL code and must know
which way the STACK FRAME is being managed), and HEAP, which manages
memory differently in the two modes.
.hl3 HEAP.MAC
.nj;HEAP.MAC was the most extensively modified routine in the library.
If you are interested in the changes there, please refer to the code
itself.  It is reasonably well documented internally.
The header associated with each block allocated via NEW is now
THREE words, to include full addresses and larger size (an un-allocated
block can be many sections).
.hl2 Changes in PASCMP
.nj;There were a number of changes made in the compiler itself.
.hl3 Mnemonic OP-CODES
.nj;All OP-CODES used in the compiler now have mnemonic definitions.
They are of the form OP__name, for example OP__JRST, OP__SETZ, OP__JSYS.
This one change alone makes it impossible to get a useful FILCOM of
the new version against the old version.  Also, the whole source
was run thru PFORM and reformatted.  One last thing to confound anybody
who wanted to run a FILCOM, lots of old useless comments (such as
"fixed bug in xxx") were removed.  While it is regretable that FILCOM
(or REDIT) is not useful, anyone familiar with the code will surely
agree it was past due for a general cleanup.
.hl3 Stack Frame management
.nj;All local variables (those defined within a procedure) are stored
on the STACK.  The stack is pointed to by two registers 17 (TOPP or P)
and 16 (BASIS or O).  In the single section mode, both of those registers
contain two halves.  In the extended address mode, each can only contain
one full word address.  That is one of the most significant differences between
the two modes, and one of the two reasons that code generated for one mode
cannot be used with the other mode.  (The other reason is the XBLT instruction,
which will not work in section 0).
When copies of TOPP and BASIS are stored
in the current stack frame, to allow unwinding of the stack, TOPP is
stored in one word and BASIS in another (TOPP at 0(BASIS) and BASIS at
-1(BASIS)).  In order to store the data that was in the left half of
BASIS, it was necessary to expand the stack frame by one word (?).
The current left half of BASIS is stored at -2(BASIS).
This is of very little interest to most users, unless you are trying
to understand what is in the stack.  It is, of course, quite important
to the debugger.
.hl3 New INTERNAL symbols
Four new symbols are defined INTERNAL in the code generated by PASCAL.
They are %PASVR, %PASXT, %PASFB, and (for main programs only) .MAIN.
.b1;%PASXT is a flag to the initialization routines to signal which mode
(single section(0) or extended addressing (1)) was used in the compilation.
.b1;%PASVR is the major version number of the compiler.
.b1;%PASFB is the length of the file block.
.b1;If any of the %PASxx symbols conflicts with the same symbols defined
in the library, LINK will issue a warning.
.b1;_.MAIN.#is defined to aid the programmer who wants to use
DDT, as it is a good place for a breakpoint after the initialization
is complete.  It also prevents accidental loading of two main programs.
.hl3 Entry Vector
.nj;In order to allow extended-address mode programs to be started in
a non-zero section (available in release 5), an entry vector was added.
The entry vector is located at the end of the initialization code and is
three words long (a JRST to the start address, a JRST to END for REENTER
(to close files), and the version number).
.hl3 PDDT.
.nj;To make PASDDT work conveniently in extended address mode, rather
than change all the JUMP and SKIPA instructions (which give the line numbers)
to LUUOs, an extra instruction was added per line of source code.
It is simply XCT PDDT.#where PDDT.#is very similar to FDDT.#used by
FORTRAN code to get into FORDDT.  PDDT.#normally contains a JFCL during
execution, so it is just a no-op.  When PASDDT enters STEP mode PDDT.#is
changed to a call to PASDDT.  When a breakpoint is set, the XCT PDDT.#is
replaced by a call to PASDDT.
This was done since the overhead for a LUUO is quite high in extended
address mode.
.hl1 Associated changes to TOPS-20 Monitor and EXEC.
.hl2 Monitor
.nj;There are no required monitor changes, although a fix for the
FLKTIM BUGCHK (see "known bugs and deficiencies" below) would be a
nice thing to consider.
.hl2 EXEC
.nj;No EXEC changes are REQUIRED, but some changes are nice.
If your EXEC already has mods to recognize .PAS as PASCAL source,
you may want to add "/EXTEND", "/STACK", and some other switches
which can be passed to the PASCAL compiler.
The following changes will implement the /EXTEND switch:
.lm8.literal
***** Change #1; Page 1, line 1; Page 1, line 1
$ ---------------------------------
$
***** Change #2; Page 1, line 213; Page 1, line 213
F%NBIN==1B21		;NOBINARY FOR THIS FILE
F%OPT==1B22		;PRODUCE OPTIMIZED OUTPUT
F%DEB==1B23		;DEBUG CODE FOR THIS FILE
F%LIB==1B24		;LIBRARY SEARCH OF THIS FILE
F%LSYM==1B25		;LOAD LOCAL SYMBOLS
$ ---------------------------------
F%NBIN==1B21		;NOBINARY FOR THIS FILE
F%OPT==1B22		;PRODUCE OPTIMIZED OUTPUT
F%DEB==1B23		;DEBUG CODE FOR THIS FILE
F%LIB==1B24		;LIBRARY SEARCH OF THIS FILE
F%LSYM==1B25		;LOAD LOCAL SYMBOLS
F%XTND==1B26		;PASCAL only - use extended addressing
$
***** Change #3; Page 1, line 715; Page 1, line 714
	CALL	PROUT		;DUMP PERIOD
	CALL	PUTDF0		;Q1 STILL HAS PNTR
	  JFCL			;IGNORE END-OF-SPEC RETURN
BLDC2A:	SKIPE	B,PPN(P2)	;NEED PPN?
	CALL	PUTPPX		;YES - DUMP IT
$ ---------------------------------
	CALL	PROUT		;DUMP PERIOD
	CALL	PUTDF0		;Q1 STILL HAS PNTR
	  JFCL			;IGNORE END-OF-SPEC RETURN
BLDC2A:	SKIPE	B,PPN(P2)	;NEED PPN?
	CALL	PUTPPX		;YES - DUMP IT
	CAIN	P4,LT.PAS	;PASCAL ONLY
	 JRST	[HRROI	B,[ASCIZ "/EXTEND"]
		TXNE	P5,F%XTND ;WANT EXTENDED?
		 CALL	TSOUT0	;YES
		JRST	BLDCM2]
$
***** Change #4; Page 1, line 2674; Page 1, line 2668
	NM (BINARY,S%TOFF!S%FRH,F%NBIN)
	NM (COBOL,S%LTYP,LT.CBL)
	NM (COMPILE,S%FRH,F%CMPL)
	NM (CREF,S%FRH,F%CREF!F%LIST)
	NM (DDT,S%FLH,F%DDT)
$ ---------------------------------
	NM (BINARY,S%TOFF!S%FRH,F%NBIN)
	NM (COBOL,S%LTYP,LT.CBL)
	NM (COMPILE,S%FRH,F%CMPL)
	NM (CREF,S%FRH,F%CREF!F%LIST)
	NM (DDT,S%FLH,F%DDT)
	NM (EXTEND,S%FRH,F%XTND)
$
.end literal
.lm 0
.hl1 Known bugs and deficiencies
.hl2 strings in JSYS calls
.nj;As mentioned in the section on incompatibilities, when a string
is used as an argument in a user JSYS call, the byte pointer is loaded
into the register, with the address field zero, and the index field
set to 14.  The location of the string is loaded into AC14.  This has
one ramifications:
.ls
.le;the "-1:name" form will not work, since the -1 will overwrite the
14 in the index field.  It is not necessary anyway, since "name" alone
will load a byte pointer if "name" is a packed array of characters.
.els
.hl2 Limitation on INITPROCEDURES
.nj;It is not possible to initialize data in the extended data area
(.XDATA), since such data does not actually appear in the .REL file.
.hl2 FLKTIM BUGCHK
.nj;Due to a bug in TOPS-20 release 4, it is possible (fairly likely)
to get a FLKTIM BUGCHK after running any program in extended address mode.
There is a simple patch for this, but the patch was broken by the
second AUTOPATCH tape.  The BUGCHK simply causes the user to be hung
for up to a minute when the next program is run, it causes no other
known problems.
.hl2 Incomplete implementation of HEAP.
.nj;The complex memory manager, used when DISPOSE is called from anywhere
in the program, cant yet handle discontiguous sections.  This could cause
problems if the user allocates and deallocates whole sections.  One
simple way around this is to NOT call RELSECTIONS, but simply re-map
the section yourself.  Code to fix this could be added by anyone familiar
with the code.  I just ran out of time and didnt feel that was a very
serious restriction.
.hl1 Who to contact
.nj;If you encounter any problems with this version of PASCAL, please
contact:
.b1.i5;Charles Hedrick
.i5;CCIS
.i5;Rutgers University
.i5;Hill Center
.i5;P.O. Box 879
.i5;Piscataway, NJ  08854
.i5;Phone (201)932-3088
.i5;Arpanet mail address: HEDRICK@RUTGERS
