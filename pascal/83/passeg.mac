	title PASSEG - sharable segment for Pascal-20

comment \

This module generates the sharable segment itself.  It is mapped
in by the user's program at startup.  Certain pieces of the segment
must be in fixed locations, so the user can find them.  The module
PASLOW defines those locations.  It must agree with this module.
The segment has two parts:
  - Variables, i.e. impure portions.  They are in the lower part
	of the segment.  This file lists the first few variables.
	They are the ones that must also be known to the user's code.
	Those declarations must match declarations in PASLOW.
	Note that a few variables are set up before the sharable
	segment is loaded. At the moment we put those down in unused
	parts of the job data area.  If necessary, they could go on the
	page before the sharable segment.
  - Code, i.e. pure portions.  The beginning of the code is a dispatch
	vector.  This allows us to change the size and positions of
	the actual routines. That table is in a fixed order.  In order
	to make sure it agrees with the one in PASLOW, both this module
	and PASLOW use a common file, PASVEC, to define the elements
	of the jump table.  Here is what is actually in that table:
	  - hiseg to hiseg + 7:  LINK sets up a "vestigial job data area"
  	  - hiseg + 7 to hiseg + 207:  table used for character mapping
	  - hiseg + 210: beginning of actual entries.
\
	
	search pasunv

	twoseg 400000

	subttl low segment - data area

;this module contains only the data that must be known to the user's
;program.  All declarations here must agree with PASLOW.

	reloc 0

	search pasunv,monsym

	entry input,output,tty,ttyout,new
	entry %cclsw,%rnnam,%rnppn,%rndev,%ccldn
	entry pddt.,lstnew,in.ddt,lstnwl,stk.bt,cainit
	extern no.ddt,ca.nit

ifn klcpu,<
	entry sn.cod,sn.hep
> ;ifn klcpu

input:	block 45
output:	block 45
tty:	block 45
ttyout:	block 45
%cclsw=100
%rnnam=101
%rnppn=102
%rndev=103
%ccldn=104
pddt.:	pushj p,no.ddt		;this may be changed by PASDDT
lstnew=105
in.ddt:	block 1			;non-zero if we are in PASDDT
stk.bt:	block 1			;bottom of stack
				;also # sections in stak before creating it
ful.ca:	block 1			;non-zero if fancy memory allocator

ifn klcpu,<
lstnwl:	block 1			;"lstnew" for gnew.l
sn.cod:	block 1			;code section (0 or sn%cod)
sn.hep:	block 1			;desired last section of heap
>;ifn klcpu

cainit:	skipn ful.ca		;if fancy memory alloc loaded
	popj p,			;no - no-op
	jrst ca.nit		;yes - do the real one

;This is for the benefit of anyone in the hiseg who may call NEW, e.g.
;NEWCL.
new:	skipn ful.ca		;if fancy memory alloc loaded
	jrst getnew		;no
	jrst xnew.		;yes

;here if the user calls a nonexistent entry vector address

psskew:	hrroi a,[asciz / You have called a nonexistent function in the Pascal runtime system.
 Probably the person who created this core image was using a newer
 version of SYS:PASLIB.REL and SYS:PASSEG.EXE than the ones that you are
 now getting.  If the core image was created on this system, you may need
 to type
    define sys: new:,sys:
 before running it. If you imported this program from a different
 computer, you may have to get their version of SYS:PASSEG.EXE/]
	esout
	haltf
	jrst .-1

	subttl high segment - code

;The dispatch vector is generated by PASVEC.MAC, using the macro
;definition here.

	reloc

;dummies - these things are only used by extended addressing

	intern .xstrt,xmais.

.xstrt==0
xmais.==0



;DEFVEC defines one element of the entry vector.  The actual code
;  comes by searching PASLIB.

define defvec(ent),<jrst ent##>

;DEFAKE is similar, but is used when PASLOW must use a different name.

define defake(dum,ent),<jrst ent##>
define defarb(dum,ent),<ent>
define defdum(dum,ent),<ent>
